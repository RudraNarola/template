{
    "Advance template": {
        "prefix": "qwe",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define int long long",
            "const int mod = 1e9+7;",
			"",
            "void solve()",
            "{",
            "    $1",
            "}",
            "",
            "signed main()",
            "{",
            "#ifndef ONLINE_JUDGE",
            "    freopen(\"d.txt\", \"w\", stderr);",
            "#endif",
            "    ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);",
            "    int t = 1;",
            "    cin >> t;",
            "    while(t--) solve();",
            "    return 0;",
            "}"
        ],
        "description": "Log output to console"
    },
    "sqrt prime test": {
        "prefix": "primeTest",
        "body": [
            "bool isPrime(int num)",
            "{",
            "    if (num <= 1)",
            "        return false;",
            "    if (num == 2)",
            "        return true;",
            "    if (num % 2 == 0)",
            "        return false;",
            "    for (int i = 3; i * i <= num; i += 2)",
            "        if (num % i == 0)",
            "            return false;",
            "    return true;",
            "}"
        ],
        "description": "Log output to console"
    },
    "seive prime test": {
        "prefix": "seivePrimeTest",
        "body": [
            "const int N = 1179859;",
            "int is_Prime[N];",
            "void Seive()",
            "{",
            "    for (int i = 1; i <= N; i++)",
            "        is_Prime[i] = 1;",
            "    is_Prime[0] = is_Prime[1] = 0;",
            "    for (int i = 2; i * i <= N; i++)",
            "    {",
            "        if (is_Prime[i])",
            "        {",
            "            for (int j = i * i; j <= N; j += i)",
            "                is_Prime[j] = 0;",
            "        }",
            "    }",
            "}"
        ],
        "description": "Log output to console"
    },
    "binary exponential": {
        "prefix": "binoexpo",
        "body": [
            "const long long M = 1e18 + 7;",
            "int power(int a, int b, long long m = M)",
            "{",
            "    int ans = 1;",
            "    while (b != 0)",
            "    {",
            "        if (b & 1)",
            "        {",
            "            ans = (ans * a) % m;",
            "        }",
            "        a = (a * a) % m;",
            "        b = b >> 1;",
            "    }",
            "    return ans;",
            "}"
        ],
        "description": "Log output to console"
    },
    "gcd and lcm": {
        "prefix": "gcd",
        "body": [
            "int gcd(int a, int b)",
            "{",
            "    if (b == 0)",
            "        return a;",
            "    return gcd(b, a % b);",
            "}",
            "int lcm(int a, int b) { return ((a * b) / gcd(a, b));}"
        ],
        "description": "Log output to console"
    },
    "for thy loop": {
        "prefix": "ff",
        "body": [
            "for(int i=0; i<n; i++)",
		],
        "description": "Log output to console"
    },
    "say Yess!!": {
        "prefix": "cy",
        "body": [
            "cout << \"YES\\n\";"
        ],
        "description": "Log output to console"
    },
    "say Nooo!!": {
        "prefix": "cn",
        "body": [
            "cout << \"NO\\n\";"
        ],
        "description": "Log output to console"
    },
    "make thy vector": {
        "prefix": "vec",
        "body": [
            "vector<int> v(n);"
        ],
        "description": "Log output to console"
    },
    "cin thy vector": {
        "prefix": "cv",
        "body": [
            "cin >> v[i];"
        ],
        "description": "Log output to console"
    },
    "cout thy vector": {
        "prefix": "co",
        "body": [
            "cout << v[i] << \" \";"
        ],
        "description": "Log output to console"
    },
    "sort thy vector": {
        "prefix": "sov",
        "body": [
            "sort(v.begin(),v.end());"
        ],
        "description": "Log output to console"
    },
    "test it ": {
        "prefix": "test",
        "body": [
            "int t;",
            "cin >> t;",
            "while (t--)",
            "{",
            "    $1",
            "}"
        ],
        "description": "Log output to console"
    },        
    "Simpler template": {
            "prefix": "zxc",
            "body": [
                "#include ",
                "using namespace std;",
                "",
                "int main()",
                "{",
                "    $1",
                "    return 0;",
                "}"
            ],
            "description": ""
    },
    "Trie":{ 
        "prefix": "trie",
        "body": [
            "class TrieNode",
            "{",
            "private:",
            "    TrieNode *links[26];",
            "    bool flag;",
            "",
            "public:",
            "    TrieNode()",
            "    {",
            "        flag = false;",
            "        for (int i = 0; i < 26; i++)",
            "            links[i] = NULL;",
            "    }",
            "",
            "    bool containsKey(char ch)",
            "    {",
            "        return links[ch - 'a'] != NULL;",
            "    }",
            "",
            "    TrieNode *getNode(char ch)",
            "    {",
            "        return links[ch - 'a'];",
            "    }",
            "",
            "    void setKey(char ch, TrieNode *node)",
            "    {",
            "        links[ch - 'a'] = node;",
            "    }",
            "",
            "    void setEnd()",
            "    {",
            "        flag = true;",
            "    }",
            "",
            "    bool isEnd()",
            "    {",
            "        return flag;",
            "    }",
            "};",
            "",
            "class Trie",
            "{",
            "private:",
            "    TrieNode *root;",
            "",
            "public:",
            "    Trie()",
            "    {",
            "        root = new TrieNode();",
            "    }",
            "",
            "    void insert(string word)",
            "    {",
            "        TrieNode *node = root;",
            "        for (auto i : word)",
            "        {",
            "            if (!node->containsKey(i))",
            "            {",
            "                node->setKey(i, new TrieNode());",
            "            }",
            "            node = node->getNode(i);",
            "        }",
            "",
            "        node->setEnd();",
            "    }",
            "",
            "    bool search(string word)",
            "    {",
            "        TrieNode *node = root;",
            "        for (auto i : word)",
            "        {",
            "            if (!node || !node->containsKey(i))",
            "            {",
            "                return false;",
            "            }",
            "            node = node->getNode(i);",
            "        }",
            "",
            "        return node->isEnd();",
            "    }",
            "",
            "    bool startsWith(string word)",
            "    {",
            "        TrieNode *node = root;",
            "        for (auto i : word)",
            "        {",
            "            if (!node || !node->containsKey(i))",
            "            {",
            "                return false;",
            "            }",
            "            node = node->getNode(i);",
            "        }",
            "",
            "        return true;",
            "    }",
            "};",
            ""
        ],     
        "description": ""
    },
    "Segment Tree for Min Query": {
    "prefix": "segg",
    "body": [
        "class SegT",
        "{",
        "    vector<long long> seg;",
        "",
        "public:",
        "    SegT(int n)",
        "    {",
        "        seg.resize(4 * n + 1);",
        "    }",
        "",
        "    void build(int index, int low, int high, vector<long long> &arr)",
        "    {",
        "        if (low == high)",
        "        {",
        "            //  CHANGE ACC. TO PROBLEM",
        "            seg[index] = arr[low];",
        "            return;",
        "        }",
        "",
        "        int mid = (low + high) / 2;",
        "        build(2 * index + 1, low, mid, arr);",
        "        build(2 * index + 2, mid + 1, high, arr);",
        "",
        "        //  CHANGE ACC. TO PROBLEM",
        "        seg[index] = min(seg[2 * index + 1], seg[2 * index + 2]);",
        "    }",
        "",
        "    int query(int index, int low, int high, int L, int R)",
        "    {",
        "        // No Overlap  ...   low high  L R      L R   low high",
        "        if (high < L || low > R)",
        "        {",
        "            //  CHANGE ACC. TO PROBLEM",
        "            return INT_MAX;",
        "        }",
        "",
        "        // Full Overlap     L  low high  R",
        "        if (low >= L && high <= R)",
        "        {",
        "            return seg[index];",
        "        }",
        "",
        "        // Partial Overlap",
        "        int mid = (low + high) / 2;",
        "        int left = query(index * 2 + 1, low, mid, L, R);",
        "        int right = query(index * 2 + 2, mid + 1, high, L, R);",
        "",
        "        //  CHANGE ACC. TO PROBLEM",
        "        return min(left, right);",
        "    }",
        "",
        "    void update(int index, int low, int high, int changeIndex, int val)",
        "    {",
        "        if (low == high)",
        "        {",
        "            seg[index] = val;",
        "            return;",
        "        }",
        "",
        "        int mid = (low + high) / 2;",
        "",
        "        if (changeIndex <= mid)",
        "        {",
        "            update(2 * index + 1, low, mid, changeIndex, val);",
        "        }",
        "        else",
        "        {",
        "            update(2 * index + 2, mid + 1, high, changeIndex, val);",
        "        }",
        "",
        "        //  CHANGE ACC. TO PROBLEM",
        "        seg[index] = min(seg[2 * index + 1], seg[2 * index + 2]);",
        "    }",
        "};",
        ""
    ],
    "description": "Segment Tree for min query"

    },
    "Disjoint Union Set": {
    "prefix": "dus",
    "body": [
        "class DUS",
        "{",
        "public:",
        "    vector<int> parent, size, rank;",
        "    DUS(int n)",
        "    {",
        "        parent.resize(n + 1);",
        "        size.resize(n + 1);",
        "        rank.resize(n + 1, 0);",
        "        for (int i = 0; i <= n; i++)",
        "            parent[i] = i;",
        "        for (int i = 0; i <= n; i++)",
        "            size[i] = 1;",
        "    }",
        "",
        "    int fup(int node)",
        "    {",
        "        if (parent[node] == node)",
        "            return node;",
        "",
        "        return parent[node] = fup(parent[node]);",
        "    }",
        "",
        "    void size_union(int i, int j)",
        "    {",
        "        int pi = fup(i);",
        "        int pj = fup(j);",
        "",
        "        if (pi == pj)",
        "            return;",
        "",
        "        if (size[pi] > size[pj])",
        "        {",
        "            parent[pj] = pi;",
        "            size[pi] += size[pj];",
        "        }",
        "        else",
        "        {",
        "            parent[pi] = pj;",
        "            size[pj] += size[pi];",
        "        }",
        "    }",
        "",
        "    void rank_union(int i, int j)",
        "    {",
        "        int pi = fup(i);",
        "        int pj = fup(j);",
        "",
        "        if (pi == pj)",
        "            return;",
        "",
        "        if (size[pi] < size[pj])",
        "        {",
        "            parent[pj] = pi;",
        "        }",
        "        else if (size[pj] < size[pi])",
        "        {",
        "            parent[pj] = pi;",
        "        }",
        "        else",
        "        {",
        "            parent[pj] = pi;",
        "            rank[pi]++;",
        "        }",
        "    }",
        "};"
    ],
    "description": ""
    },
    "Leetcode template": {
        "prefix": "leetcode",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define ll long long",
            "const int mod = 1e9+7;",
			"",
            "$1",
        ],
        "description": "Log output to console"
    },
}
